# 지하철 노선도 미션

[ATDD 강의](https://edu.nextstep.camp/c/R89PYi5H) 실습을 위한 지하철 노선도 애플리케이션

# 요구사항 & 구현

## 구간 추가

- 구간추가 판단전 공통 예외 케이스를 검증한다.
- 구간 추가시 상행추가, 하행추가, 중간추가 로직과 검증로직음 담당하는 도메인 추가
    - 액션판단
        - 상행추가
            1. 구간을 순회하며 상행역이 신규 상행역과 같은지 판단한다.

### 역 사이에 새로운 역을 등록할 경우

- 기존 구간 A-C에 신규 구간 A-B를 추가하는 경우 A역을 기준으로 추가
    - 기존 마지막에만 추가가능한 제약조건을 변경해야함
    - 기존 구간과 신규 상행역이 같은 Section을 찾는다
- 새로운 길이를 뺀 나머지를 새롭게 추가된 역과의 길이로 설정
    - 신규구간을 기존 구간 앞에 추가
    - 기존 구간 업데이트
        - 기존 상행역 = 신규 하행역
        - 거리 = 기존구간거리 - 신규구간거리

### 새로운 역을 상행 종점으로 등록할 경우

- 신규 하행역과 기존 상행역이 같은지 체크한다.

### 새로운 역을 하행 종점으로 등록할 경우

- 기존 로직과 동일

### 노선 조회시 응답되는 역 목록 수정

1. 상행 종점이 상행역인 구간을 먼저 찾는다.
2. 그 다음, 해당 구간의 하행역이 상행역인 다른 구간을 찾는다.
3. 2번을 반복하다가 하행 종점역을 찾으면 조회를 멈춘다.

- LinkedList로 구현
- 조회 방식 고민
    - 최초 저장시 Seciton에 order 컬럼을 두고 순서에 맞게 저장. 저장/삭제시 업데이트
        - 장점 : 조회시 정렬이 쉽다. 운영시 DB에 직접 select 하는 경우 파악이 쉬움
        - 단점 : 중간에 입력/삭제 하는경우 나머지 모든 order를 업데이트해야됨
    - 조회시 어플리케이션에서 직접 정렬
        - 장점 : 저장/삭제시 업데이트가 필요없음
        - 조회 : 조회시마다 정렬을 수행해야함
            - 정렬결과를 속성으로 가지는 경우 성능을 개선할 수 있으나 수정/삭제시 다시 생성하는 방법이 있으나 저장 삭제시 항상 수행해야 하므로 관리포인트가 늘어남. 실수할경우 데이터가 틀어질수 있다.

지하철역의 추가 삭제는 빈도수가 낮으므로 조회성능에 강점이 있는 저장시 정렬방식 선택

## 예외 케이스

- Sections addSection 검증로직 수정할것
- 역 사이에 새로운 역을 등록할 경우 기존 역 사이 길이보다 크거나 같으면 등록을 할 수 없음 (중간 저장 액션 검증)
    - 신규 distance > 기존 distance 면 등록실패
- 상행역과 하행역이 이미 노선에 모두 등록되어 있다면 추가할 수 없음
- 상행역과 하행역 둘 중 하나도 포함되어있지 않으면 추가할 수 없음

## 구간 삭제

### 예외 처리

1. 구간이 하나이면 삭제 불가
2. 일치 하는 역이 없으면 삭제 불가

### 상행역 삭제

- 판단 : 역id로 모든 구간의 상행억중 일치하는 역을 찾는다. 찾은 구간의 order가 0이면 상행역
- 삭제 : 가장 처음 구간을 삭제 (list의 index 0번 삭제처리)

### 중간역 삭제

- 판단 : 역id로 모든 구간의 상행역중 일치하는 구간을 찾는다. 찾은 구간의 order가 0이 아니면 중간역
- 삭제 : 역id로 모둔 구간의 상행역중 일치하는 구간을 찾는다. 그 앞의 구간에 거리를 더하고 하행역을 바꾼다. 찾은 구간을 삭제한다

### 하행역 삭제

- 판단 : 역id로 모든 구간의 하행역중 일치하는 역을 찾는다. 찾은 구간이 마지막 이면 하행역. 마지막 판단은 구간의 order와 Sections size() -1 이 같을 떄이다
- 삭제 : 가장 마지막 구간을 삭제 (list의 size-1 번쨰 인덱스 삭제)

## 경로 조회 기능 추가

### 요청 & 응답 정의

- 요청 : 출발역id, 도착역id
- 응답 : 역목록(stations), 총거리(distance)

### 기능 상세 구현

1. 출발/도착역 아이디로 노선을 모두 조회 하고
    - `Lines.from(Set<Line>)`
    - 같은 같은 노선의 경로를 조회하면 List로 조회시 중복값이 생길수 있기때문에 Set으로 조회한다
2. PathFinder를 초기화한다
    - `PathFinder = PathFinder.from(PathStrategy)`
    - 알고리즘은 변경될수 있으므로 외부에서 주입받는다
2. PathFinder로 최단경로를 구한다.
    - `Path = PathFinder.findShortest(Lines)`

    1. Line의 Sections를 합친다 -> `Sections = Lines.mergeSection()`
        - 내부적으로 `Sections = sections.merge(sections)` 처리
    2. PathStrategy 값을 입력한다
        - `strategy.init(sections)` 실행
           - 내부에서 `sections.initGraph(strategy)` 호출해 `strategy` 에 정보를 입력한다.
             - Q.그래프에 구간을 넣는데 구간의 값을 노출하지 않기위해 sections의 인자로 전략를 넘기고 있어 가독성이 떨어지지 않을까?
           - `strategy.add(section)` 호출
3. 컨트롤러에서 Path를 PathResponse로 변환후 리턴

### 예외 처리

- 출발역 == 도착역
- 출발역과 도착역이 연결안됨
- 출발역, 도착역이 없음